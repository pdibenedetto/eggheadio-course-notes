ðŸ“¹[Compile Tailwind to CSS with gulp](https://egghead.io/lessons/tailwind-compile-tailwind-to-css-with-gulp)

Beginning in an empty project with an `index.html` that renders *"Hello world"* to the screen, it's time to install Tailwind and Gulp.

> Yarn and NPM are package managers for Node.js modules. It's entirely up to you which to use, and instructions for both will be provided

*yarn*
```sh
yarn add tailwindcss gulp gulp-postcss --dev
```
*npm*
```sh
npm install tailwindcss gulp gulp-postcss --save-dev
```

Run one of these commands to begin installing your modules and then import them into a `gulpfile.js` in your project root.

```sh
touch gulpfile.js
```
```js
const gulp = require("gulp")
const postcss = require("gulp-postcss")
const tailwindcss = require("tailwindcss")
```

Gulp is a fantastic little javascript task runner. When we're finished writing our tasks, a single command will read our configuration, parse our source code, and output a compiled CSS file containing all the Tailwind styles we could ever dream of using.

```js
gulp.task("css", () => {
  return gulp
})
```

The least exciting task is one that does nothing. To begin doing something, Gulp's `.src()` method will will arm Gulp with our source CSS file

```diff
gulp.task("css", () => {
  return gulp
+   .src("./src/styles.css")
})
```

The `.pipe()` method feeds the CSS into the `gulp-postcss` module, which runs its own set of preprocessors and postprocessors â€“ the most important to us is Tailwind

```diff
gulp.task("css", () => {
  return gulp
    .src("./src/styles.css")
+   .pipe(postcss([
+     tailwindcss(),
+   ]))
})
```

Tailwind contains an extraordinary number of CSS rules, many of which do not currently have first class support in every browser. For example, before the `transform` property was widely supported by the latest browsers, each browser had a prefixed "beta" property like `-webkit-transform` and `-moz-transform` and `-ms-transform` and `-o-transform`.

Managing that by hand was (it's commonly agreed) ridiculous. Fortunately, PostCSS supports a module called `autoprefixer` which does that ridiculous job for us.

```diff
gulp.task("css", () => {
  return gulp
    .src("./src/styles.css")
    .pipe(postcss([
      tailwindcss(),
+     require("autoprefixer")
    ]))
})
```

The final stage in the pipeline is to output the processed CSS file somewhere. For lack of a better location, `./` points to the current directory, and Gulp's `.dest()` method will deliver our file there.

```diff
gulp.task("css", () => {
  return gulp
    .src("./src/styles.css")
    .pipe(postcss([
      tailwindcss(),
      require("autoprefixer")
    ]))
+   .pipe(gulp.dest("./"))
})
```

Hardcoding our filenames and paths directly in the task is fine in small projects, but as the project grows, files move around and having one common place to keep track of them is an easy way to save future headaches.

```diff
+ const PATHS = {
+   css: "./src/styles.css",
+   dist: "./",
+ }

  gulp.task("css", () => {
    return gulp
+     .src(PATHS.css)
      .pipe(postcss([
        tailwindcss(),
        require("autoprefixer")
      ]))
+     .pipe(gulp.dest(PATHS.dist))
  })
```

The Tailwind command line can initialize a new Tailwind config file. After running this command, Tailwind generates what is essentially a gigantic javascript object containing values for colors, spacing, scales, and more.

```sh
./node_modules/.bin/tailwind init tailwind.js
```

```diff
  const PATHS = {
    css: "./src/styles.css",
+   config: "./tailwind.js",
    dist: "./",
  }

  gulp.task("css", () => {
    return gulp
      .src(PATHS.css)
      .pipe(postcss([
+       tailwindcss(PATHS.config),
        require("autoprefixer")
      ]))
      .pipe(gulp.dest(PATHS.dist))
  })
```

The default configuration is good enough for now, but we'll find ourselves making some changes shortly.

The last file we're missing is `./src/styles.css` specified in `PATHS.css`.

```sh
touch src/styles.css
```
```css
@tailwind preflight;
@tailwind utilities;
```

These [at-rules](https://github.com/postcss/postcss/blob/master/docs/plugins.md) are how PostCSS loads plugins. Tailwind's `preflight` module standardizes and resets the browser's default styling. That means elements like `<h1>` and `<h6>` become identical, and it's up to the user to style them as desired with the utility classes that are generated by including the `utilities` module.

To recap what we've built so far, these two Tailwind modules are loaded by our Gulp task in the `.src(PATHS.css)` step, then piped through `tailwindcss` and our Tailwind config file, through `autoprefixer`, and finally exported out into the current directory by `.pipe(gulp.dest(PATHS.dist))`

```sh
gulp css
```

If everything has gone swimmingly so far, you should now see a `styles.css` in your main directory.

In the `index.html` file, link the new stylesheet by placing a `<link>` tag within the `<head>` section

```diff
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie-edge">
    <title> Compile Tailwind to CSS with Gulp </title>
+   <link rel="stylesheet" href="./styles.css">
  </head>
  <body>
    <h1> Hello, world! </h1>
  </body>
</html>
```

Everything should work now! To test it out, play around and add some Tailwind classes to your html

```diff
<body>
+ <h1 class="text-purple bg-grey-lighter p-8 mt-8">
+   Hello, Tailwind!
  </h1>
</body>
```
Next lesson: [Create Custom Utility Classes in Tailwind](https://egghead.io/lessons/tailwind-create-custom-utility-classes-in-tailwind)

Previous: [Course Introduction](https://egghead.io/lessons/tailwind-composing-css-utility-classes-with-tailwind-course-introduction)